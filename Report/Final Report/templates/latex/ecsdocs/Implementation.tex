%% ----------------------------------------------------------------
%% Implementation.tex
%% ---------------------------------------------------------------- 
\chapter{Implementation} \label{Chapter: Implementation}
\section{Setting up Development Environment}
In order to create and migrate the smart contract onto the blockchain I used a tool called Truffle. This had boilerplate code which had a .sol contract file and a initial\textunderscore migration.js and a deploy\textunderscore contracts.js. After writing code in the .sol file and making sure to deploy it in the deploy\textunderscore contracts.js, you could then run truffle compile to create .json build files which contains fields such as the abi. This could then be deployed to the “real” blockchain, however while in development, Truffle has a tool "develop", which allows you to deploy the smart contract to a local network. It also provides several addresses preloaded with Ethereum, this allows me to test my program without having to pay any money.  
\section{Club Contract Inheritance}
I decided to split my Club smart contract into three; RegistrationClub, VotingClub and BudgetClub. With BudgetClub inheriting from VotingClub and VotingClub inheriting from RegistrationClub. The first reason this was done was to increase readability. Another reason is that I want to make it easier for developers to adapt my smart contract to their situation. For example, a completely different way of choosing representatives, would mean that only VotingClub needs to be changed. 
\\
I also created a library called MyLib which will contain all my structs. Which I imported into my other contracts.
\section{Registration Club}
This contract needs to take a registration cost when it is created, and then allow users to pay that much Ethereum to register. It subsequently needs to store that user in an array, as a Struct containing the user's name and address \\
I also needed to add the functionality to allow users to change the registration cost if a super-majority of users wish it.  First, I added a mapping which takes a registered user index and returns their current suggestion that user has for the new registration cost. When a new user is registered, I will set their suggestion to the current registration cost. After that I needed the ability to submit a new registration cost suggestion, and another to iterate through all the submissions and check if a super majority of the same submissions has been reached. \\
An important part of the code is that checkRegistrationSuggestions() is constant and public. This is important as running changeRegistrationCost() costs gas even if no changes are made to the registration cost. Therefore, a user only wants to run changeRegistrationCost() when he is certain that it will change the registration cost. A user can do this by running checkRegistrationSuggestions() for free as it is constant, and therfore does not need to be uploaded to the blockchain, and seeing if the return is a value different than the current registration cost.
\section{Voting Club}
The basic features this needs to implement is the ability to start the voting, each user to submit one list of ranked users, end voting and then rank each user by their second order Copeland score. After ranking their score they will be given a weight according to the algorithm submitted (or with a default one). It will also take three variables, the registration cost, the term length and the number of representatives. \\
One problem that was spotted was that second order Copeland does pairwise comparison on each agent. This means we could be comparing users who have no votes which could cost a lot of gas. To solve this problem I added another list of users “candidates”. Any user can become a candidate and users can only vote for candidates. Thus greatly reducing the average number of pairwise comparisons. Also, since storage is expensive on smart contract I will store the candidates as a array of registeredUsers index’s instead of the User struct.\\
Another problem was getting the current time for start and ending voting. This is because block.timestamp is insecure, as a malicious actor with a large amount of computing power could create fake blocks with the wrong timestamp. However, I decided this was not of huge concern, as it would cost a lot of energy and money for very little impact (starting and ending the voting period a few second earlier or later). \\
One other important feature of solidity is that storage variable creation costs 20,000, but resizing the array length to 0 costs 5000. This means that cost of the first run of the system will cost more than the usual amount. 
\subsection{Voting Algorithm}
I also had to implement the countVotes function. This took all the votes and ranked them in order of their second order Copeland score. In order to save gas, I implemented a number of strategies. One method is to only load data from storage once. This is why I used copelandScore.length instead of candidates.length, as copelandScore.length is stored in memory. Memory load costs 3 gas whereas Storage load costs 50. This, however, leads to another problem, as the solidity language only allows 7 items of data on the stack. To solve this, I reused counter variables and split the count vote into separate functions. \\
In my algorithm, I had a inner loop and a outer for loop, which incremented $i$ and $p$ respectively, I then compared candidate[i] and candidate[p]. To save gas, I initialised the p counter as 1 + i. This made it so that I only had to do $n(n+1)/2$ pairwise comparisons to calculate all the Copeland scores. This can be done, because a defeat for one candidate increases the Copeland score of the other. If this was not done, it would have taken $n^2$ pairwise comparison. \\
After finding the Copeland score of each user and an array for each candidate of the candidates they defeated, I worked out the second order Copeland of each candidate, by summing the Copeland score of their defeated candidates. \\
One problem that I faced now, was that I could not just simply sort the second order Copeland scores. This is because, to save gas, all my variables stored the candidate list user index instead of the users themselves. This meant if I just sorted the scores, I would lose who had what particular score. To solve this problem, I sorted them, then compared the sorted and unsorted scores to create another array called "ranked", which stored the list of candidate index’s, ranked by second order Copeland scores. I used quicksort to sort, as it has the best average case time complexity  O(n log n), it also has space complexity of log n. \\
Also, while testing I realised a error occurred whereby if multiple candidates had the same second order Copeland score, they would all be ranked to the first candidate in the list. To solve this I added; secondOrderCopeland[p] = copelandScore.length  * copelandScore.length; \\
The next function to implement was the pairwise comparison function. To save gas, I decided to break the for loop as soon as either candidate i or candidate p's address has been found. This is because in Copeland score we do not need to know how much more a candidate is ranked higher, only if it is. Also during the pairwise comparison I reduced gas cost by stopping counting votes when either of the candidate has been rated higher in over half the votes. We can do this because Copeland score does not care about the quality of pairwise victories, but the quantity. This does not reduce the worst case gas cost, however the majority of times it should have significant impact. \\
\subsection{Weight Algorithm}
The last function to implement was how to weight the candidates. I decided upon creation of the contract, the creator can choose options, with developers being able to add more options. By default, I added the two simplest options, each representative getting 1 weight, and each representative get decreasingly less weight. \\
\section{Budget Club}
This smart contract had to allow representatives to submit sinks, and preferred budgets. It then had to run my decide budget algorithm. Ultimately, after a final budget is reached, the contract must send out the money according to the budget. \\
I first implemented submitting budgets and sinks . To stop representatives from abusing their ability and filling up the number of sinks with their own addresses, I created a variable numOfSinksAllowedToSubmit, which is set to sinks / reps + 1 and tracked how many sinks each representatives had already submitted. Also, users submitted budgets, will sum up to 100 and be a percentage of the money collected. This is in case more money is received after some budgets have been submitted. \\
The next code I implemented was the end budget submit. This can be done after a certain amount of time after voting had ended. I also checked that the list of representatives was not empty to make sure that users did not run this function after it had already been run once. \\
\subsection{Budget Algorithm}
Again, I tried to put as many variables I was using from storage multiple times on the stack and memory variables to save gas cost. \\
One problem I faced was that there is no built-in decimal types in solidity. This is why my utility has been scaled up by 100 times, and it is now between 0 and 10,000. The larger the scale, the more accurately I will be able to calculate utility. It also allows more granularity in coalition size factor and coalition size factor increase. Another problem caused by this, is that when negotiating a budget between representative and coalition, the total budget would not sum up to 100. To  solve this at the end of negotiating it would give each sink one more unit in the budget until it summed up to 100. This causes the problem that earlier sinks will benefit from this much more than later. However, smart contracts are deterministic and there is no way to randomise the orders. \\
Another implementation decision was to determine the order in which representatives take turns. I decided to leave the order of highest weight to lowest as it was. This was for two reasons. Firstly, would cost to reorder it, and because letting the biggest representative form coalitions first, should end the negotiation earlier, and save more gas.
I also created another function calculate100utility. This returns the utility if the preferred budget and budget are the same. This saved gas as I needed this often, and finding out how much the preferred budget overlaps with the budget is expensive. \\
\subsubsection{Negotiation}
After finding the negotiation which returned the best utility for the representative, I then had to create a function negoToBudget, which took the utility and the representative and coalition budgets and returned the new coalition budget. To achieve this, first I took each utility and increased it to what it would be if the coalition size was the quota. I then took each of them away from how much the budgets overlap. This gave me three uints,  $shardedab$ which is how much of the budgets overlap, $individuala$ which is how much of the negotiated budget is only in the representative preferred budget, and $individualb$ which is how much of the negotiated budget is only the coalitions current budget. \\
After working out these 3 variables, the function then started creating the new budget. First, all the overlapping budget is wanted by both agents so the new budget has them as well. Then I had to decide how the individual a and b were spread. Due to the way I created my utility function, if two sinks are 20 units below the budget, it generated the same utility as one sink 40 units below the budget. I decided to spread the individual utility proportionally by how far away the agent’s budget was from the other agent's budget. 
\section{Sending Out Money}
\section{Club Contract Website}
The first step was to create the html for the website. I created 5 pages; registration, home, settings, vote and representative, with a navigation bar at the top of each page allowing you to access each one. Registration allowed you to register. Home showed all registered users and allowed you to apply to be a candidate. Settings showed all the settings of the Smart Contract and allowed you to start and end voting and budget submit. Vote showed all candidates and allowed you to select them sequentially and submit the vote. Representative allowed representatives to submit sinks, view all submitted sinks and finally submit their preferred budget. \\
 The next step was to create the javascript. In order to interact with the Smart Contract you can use a library called web3.js. To use this library you must provide it with the address of your deployed contract and its ABI. Truffle provides a library called truffle-contract.js. This library allows you to automatically use the deployed address and ABI of the contract which you have migrated. This is useful during development  as the ABI will change every time the contract changes. \\
Once I connected to the Smart Contact, I then had to write functions which called the various functions on my contract. One important characteristic of the web3 library is that smart contract return values are returned as promises. A promise is an object that may produce a single value some time in the future: either a resolved value, or a reason that it’s not resolved. This is useful as this is non-blocking, and while the Smart Contract runs the function, the user can do other functions on the website. \\
Another method that I needed to implement was what account the users would be sending transactions from. I decided to do this using Metamask. Metamask is a web plugin which allows you to sign into your Ethereum account and then inject that account into the javsscript, using their library.