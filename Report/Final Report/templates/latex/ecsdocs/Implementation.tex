%% ----------------------------------------------------------------
%% Implementation.tex
%% ---------------------------------------------------------------- 
\chapter{Implementation} \label{Chapter: Implementation}
\section{Setting up Development Environment}
In order to create and migrate the smart contract onto the blockchain I used a tool called Truffle. This had boilerplate code which had a .sol contract file and a initial\textunderscore migration.js and a deploy\textunderscore contracts.js. After writing code in the .sol file and making sure to deploy in in the deploy\textunderscore contracts.js, you could then run truffle compile to create .json build files which contains fields such as the abi. This could then be deployed to the “real” blockchain, however while in development, Truffle has a tool develop, which allows you to write to deploy the smart contract to a local network. It also provides several addresses preloaded with Ethereum, this allows me to test my program without having to pay any money.  
\section{Club Contract Inheritance}
I decided to split my Club smart contract into three, RegistrationClub, VotingClub and BudgetClub. With BudgetClub inheriting from VotingClub and VotingClub inheriting from RegistrationClub. The first reason this was done was to increase readability. Another reason is that I want to make it easier for developers to adapt my smart contract to their situation. E.g A completely different way of choosing representatives, would mean that only VotingClub needs to be changed. 
\\
I also created a library called MyLib which will contain all my structs.
\section{Registration Club}
This contract needs to take a registration cost when its created, and then allow users to pay that much Ethereum to register. It then needs to store that user in a array as a Struct containing the users name and address. I also require getters to return the number of registered uses, a certain registered user and the balance in the smart contract. This was done with the following code 
\begin{lstlisting}
contract RegistrationClub {
  
  MyLib.User[] registeredUser;
  uint public registrationCost;
  
  function RegistrationClub(uint cost) public {
    registrationCost = cost;
    
  }

  function register(string name) public payable {
    if (msg.value > registrationCost && (!isRegistered(msg.sender,registeredUser)) ) {
      MyLib.User memory u;
      u.myAddress = msg.sender;
      u.name = name;
      registeredUser.push(u);
    }
  }
  
  
  function isRegistered(address sample, MyLib.User[] userList) internal pure returns (bool)
  {
    for (uint i = 0; i < userList.length; i++)
    {
      if(userList[i].myAddress == sample)
      {
        return true;
      }
    }
    return false;
  }
  function listRegisteredUsers(uint number) public constant returns (string,address) {
  return (registeredUser[number].name, registeredUser[number].myAddress);
  }
    
  function getRegisteredUsersLength() public constant returns (uint)
  {
     return registeredUser.length;
   }
   function getContractValue() public constant returns (uint)
   {
      return this.balance;
   }
}
\end{lstlisting}
I also needed to add the functionality to allow users to change the registration cost if a super-majority of users wish it.  First I added a global mapping which takes a registered user index and returns their current suggestion that user has for the new registration cost. When a new user registered I will set their suggestion to the current registration cost. After that I needed the ability to submit a new registration cost suggestion, and another to check all the submissions and check if a super majority of the same submissions has been reached. This was done with the code as follows.
\begin{lstlisting}
function changeRegistrationCostSuggestion(uint suggestion) public {
    for (uint i = 0; i < registeredUser.length; i++)
    {
      if(registeredUser[i].myAddress == msg.sender)
      {
        registrationCostSuggestions[i] = suggestion;
      }
    }
  }

  function changeRegistrationCost() public {
    uint suggestion = checkRegistrationSuggestions();
    if(suggestion != registrationCost)
    {
      registrationCost = suggestion;
    }
  }

  function checkRegistrationSuggestions() constant public returns (uint) {
      uint superMajority = registeredUser.length / 4 * 3;
      for (uint i = 0; i < registeredUser.length; i++)
      {
        uint count = 0;
        uint iSuggestion = registrationCostSuggestions[i];
        for (uint p = 0; p < registeredUser.length; p++)
        {
          if(iSuggestion == registrationCostSuggestions[p])
          {
            count ++;
          }
        }
        if (count > superMajority)
        {
          return iSuggestion;
        }
      }
      return registrationCost;
  }
\end{lstlisting}
An important part of the code is that checkRegistrationSuggestions() is constant and public. This is important as running changeRegistrationCost() costs gas even if no changes are made to the registration cost. Therefore a user only wants to run changeRegistrationCost() when he is certain that it will change the registration cost. A user can do this by running checkRegistrationSuggestions() for free and seeing if the return is a value different than the current registration cost.
\section{Voting Club}
The basic features this needs to implement is the ability to start the voting, each user to submit one list of ranked users, end voting and then rank each user by their second order Copeland score. After ranking their score they will be given a weight according to the algorithm submitted (or with a default one). It will also take three variables, the registration cost, the term length and the number of representatives. \\
One problem that was spotted was that second order Copeland does pairwise comparison on each agent. This means we could be comparing users who have no votes which could cost a lot of gas. To solve this problem I added another list of users “candidates”. Any user can become a candidate and users can only vote for candidates. This greatly reduces the average number of users I have doing pairwise comparison on. Also since storage is expensive on smart contract I will store the candidates as a array of registeredUsers index’s instead of the User struct. My apply method is as follows.


The startVote function is as follows.
\begin{lstlisting}
function startVote() public {
    if(timeVoteEnded + termLength < block.timestamp && voteStarted == false)
    {
      voteStarted = true;
      timeVoteStarted = block.timestamp;
    }
  }
\end{lstlisting}
The block.timestamp is insecure as a malicious actor with a large amount of computing power could create fake blocks with the wrong timestamp. However I decided this was not of huge concern, as it would cost a lot of energy and money and all the actor would be able to do is start and end the voting a few minutes or seconds early or late.  \\
The Vote function is as follows.
\begin{lstlisting}
function vote(address[] myVote) public {
    for (uint i = 0; i < registeredUser.length; i++)
    {
      if(registeredUser[i].myAddress == msg.sender)
      {
        if(voteStarted == true && registeredUser[i].voted == false){
          registeredUser[i].voted = true;
          votes.push(myVote);
        }
      }
    }

 }
\end{lstlisting}
The endVote function is as follows.
\begin{lstlisting}
  function endVote() public
  {

    if(timeVoteStarted + votingTime <= block.timestamp && voteStarted == true)
    {
      voteStarted = false;
      timeVoteEnded = block.timestamp;
      if(candidates.length < numberOfRepresentatives)
      {
        numberOfRepresentatives = candidates.length;
      }

      countVotes();

      candidates.length = 0;
      votes.length = 0;

    }
  }
\end{lstlisting}
The countVotes function is as follows.
\begin{lstlisting}
  function countVotes() internal {
    uint i;
    uint p;
    uint[] memory copelandScore = new uint[](candidates.length);
    uint[][] memory defeated = new uint[][](copelandScore.length);

    //init2d array
    for (i = 0; i < copelandScore.length; i++)
    {
      defeated[i] = new uint[](copelandScore.length);
    }

    //pairwise each candidate against each other
    for (i = 0; i < copelandScore.length - 1; i++)
    {
      for (p = 1 + i; p < copelandScore.length; p++)
      {
        uint pairwise = pairwiseComparison(i,p);

        if(pairwise == 0)
        {
          defeated[i][copelandScore[i]] = p;
          copelandScore[i] ++;
        }
        else if (pairwise == 1) {
          defeated[p][copelandScore[p]] = i;
          copelandScore[p] ++;
        }


      }
    }
\end{lstlisting}
In order to save gas I implemented a number of strategies. One method is to only load data from storage once. This is why I used copelandScore.length instead of candidates.length. As copelandScore.length is stored in memory. Memory load costs 3 gas whereas Storage load costs 50. This however lead to another problem, as the solidity language only allows 7 items of data on the stack. To solve this is reused counter variables and split the count vote into separate functions.
Another way I saved gas was by moving the initialising the p counter as 1 + i. This made it so my I only had to do $n(n+1)/2$ pairwise comparisons to calculate all the Copeland scores. This can be done because a defeat for one candidate increases the Copeland score of the other. If this was not done it would have taken $n^2$ pairwise comparison. 
Also during the pairwise comparison I reduced gas cost by stopping counting votes when either of the candidate has been rated higher in over half the votes. We can do this because Copeland score does not care about the quality of pairwise victories, but the quantity. This does not reduce the worst case gas cost, however the majority of times it should have significant impact. \\
Another decision I made was to break the for loop as soon as either candidate i or candidate p’s address has been found. This is because in Copeland score we do not need to know how much more a candidate is ranked higher, only if it is. This again saved gas. \\
After finding the Copeland score of each user and an array for each candidate of the candidates they defeated. I worked out the second order Copeland of each candidate by summing the Copeland score of their defeated candidates. \\
One problem that I faced now was that I could not just simply sort the second order Copeland scores. This is because to save gas all my variables stored the candidate list user index instead of the users themselves. This meant if I just sorted the scores, I would lose who had what score. To solve this problem I sorted them, then compared the sorted and unsorted scores to create another array called ranked, which stored the list of candidate index’s, ranked by second order Copeland scores. I used quick sort to sort as it has the best average case time complexity  O(n log n), it also has space complexity of log n. Also while testing I realised a error occurred where if multiple candidates had the same second order Copeland score, they would all be ranked to the first candidate in the list. To solve this I added; secondOrderCopeland[p] = copelandScore.length  * copelandScore.length; \\
The last function to implement was how to weight the candidates. I decided upon creation of the contract the creator can choose options, with developers being able to add more options. By default I added the two simplest options, each representative getting 1 weight, and each representative get decreasingly less weight. The function is as follows.
\begin{lstlisting}
function weightCandidates(uint[] ranked) public
  {
    uint weightingOptionMemory = weightingOption;
    for (uint i = 0; i < numberOfRepresentatives; i++)
    {
      MyLib.Agent memory a;
      a.u = candidates[ranked[i]];
      if(weightingOptionMemory == 0)
      {
        a.weight = 1;
      }
      else if(weightingOptionMemory == 1)
      {
        a.weight = numberOfRepresentatives - i;
      }
      listOfRepresentatives.push(a);
    }
  }
\end{lstlisting}
One other important feature of solidity is that storage variable creation costs 20,000, but resizing the array length to 0 costs 5000. This means that cost of the first run of the system will cost more than the usual amount. 
\section{Budget Club}
This smart contract had to allow representatives to submit sinks, and preferred budgets. It then had to run my decide budget algorithm. Finally after a final budget is reached, the contract must send out the money according to the budget. \\
The code for submitting budgets and sinks is as follows.
\begin{lstlisting}
function submitBudget(uint[] budget) public
  {
    if(budget.length <= numberOfSinks)
    {
      for (uint i = 0; i < numberOfRepresentatives; i++)
      {
        if(registeredUser[listOfRepresentatives[i].u].myAddress == msg.sender)
        {
          listOfRepresentatives[i].budget = budget;
        }
      }
    }
  }
  function submitSink(address spender, string name) public
  {
    if(listOfSinks.length < numberOfSinks)
    {
      for (uint i = 0; i < numberOfRepresentatives; i++)
      {
        if(registeredUser[listOfRepresentatives[i].u].myAddress == msg.sender && listOfRepresentatives[i].sinkSubmitted < numOfSinksAllowedToSubmit)
        {
          MyLib.Sink memory s;
          s.name = name;
          s.spender = spender;
          listOfSinks.push(s);
          listOfRepresentatives[i].sinkSubmitted += 1;
        }
      }
    }
  }
\end{lstlisting}
Only representatives can do these actions. Also to stop representatives from abusing their ability and filling up the number of sinks with their own addresses, I created a variable numOfSinksAllowedToSubmit which is set to sinks / reps + 1 and tracked how many sinks each representatives had already submitted. \\
The next code to implement was the end budget submit, this can be done after a certain amount of time after voting had ended. With the code as follows. I checked that the list of representatives was not empty to make sure that users did not run this function after it had already been run once.
\begin{lstlisting}
function endBudgetSubmit() public
  {
    if(listOfRepresentatives.length != 0 && timeVoteEnded + 10000 < block.timestamp)
    {
      decideBudget();
      listOfRepresentatives.length = 0;
    }
  }
\end{lstlisting}
Next I had to implement the decide budget algorithm. It is as follows. 
\begin{lstlisting}
function decideBudget() public
  {
    uint quotaMemory = quota;
    uint numberOfRepresentativesMemory = numberOfRepresentatives;
    uint[][] memory coalitionBudgets = new uint[][](numberOfRepresentativesMemory);
    uint[] memory coalitionSize = new uint[](numberOfRepresentativesMemory);
    uint[] memory playerToCoalition = new uint[](numberOfRepresentativesMemory);
    MyLib.Agent[] memory playerToAgent = new MyLib.Agent[](numberOfRepresentativesMemory);
    uint i;
    //init
    for (i = 0; i < numberOfRepresentativesMemory; i++)
    {
      playerToAgent[i] = listOfRepresentatives[i];
      coalitionBudgets[i] =  playerToAgent[i].budget;
      coalitionSize[i] = 1;
      playerToCoalition[i] = i;
    }

    uint player = 0;
    while(winningCoalition(playerToCoalition,numberOfRepresentativesMemory,playerToAgent) == numberOfRepresentativesMemory)
    {
      uint[] memory bestOffer = new uint[](2);
      uint bestCoalition = numberOfRepresentativesMemory;
      //get utility in the current coalition
      uint myAfloor = afloor(coalitionBudgets[playerToCoalition[player]],playerToAgent[player].budget,coalitionSize[playerToCoalition[player]],quotaMemory);
      for(i = 0; i < numberOfRepresentativesMemory; i ++)
      {
        //dont check coalitions with no one or the one your in
        if(playerToCoalition[player] != i && coalitionSize[i] != 0)
        {
          uint[] memory nego = offer(coalitionBudgets[i],playerToAgent[player].budget,myAfloor,coalitionSize[i],playerToAgent[player].weight);
          if(nego[0] > bestOffer[0])
          {
            bestOffer = nego;
            bestCoalition = i;
          }
        }

      }

      if(bestCoalition != numberOfRepresentativesMemory)
      {
        coalitionBudgets[bestCoalition] = negoToBudget(playerToAgent[player].budget, coalitionBudgets[bestCoalition], bestOffer, coalitionSize[bestCoalition] + playerToAgent[player].weight);
        coalitionSize[playerToCoalition[player]] -= playerToAgent[player].weight;
        coalitionSize[bestCoalition] += playerToAgent[player].weight;
        playerToCoalition[player] = bestCoalition;

      }

      if(player == numberOfRepresentativesMemory - 1)
      {
        player = 0;
      }
      else{
        player ++;
      }
      coalitionSizeFactor += coalitionSizeFactorIncrease;

    }

    finalBudget = coalitionBudgets[winningCoalition(playerToCoalition,numberOfRepresentativesMemory,playerToAgent)];

  }

  function offer(uint[] budgetCoal, uint[] budgeta, uint myAfloor, uint coalSize, uint agentWeight) constant internal returns (uint[])
  {
    uint quotaMemory = quota;
    uint myAbar = abar(coalSize, agentWeight, quotaMemory);
    uint myBbar = bbar(budgeta, budgetCoal, coalSize, agentWeight, quotaMemory);
    uint myBfloor = bfloor(coalSize, quotaMemory);
    if(myAfloor + myBfloor < myAbar + myBbar)
    {
      return negotiate(myAbar, myBbar ,myAfloor, myBfloor);
    }
    else{
      return new uint[](2);
    }
  }

  function afloor(uint[] budgetCoala, uint[] budgeta, uint coalSizea, uint quotaMemory ) constant internal returns (uint)
  {
    return calculateUtility(budgetCoala,budgeta,coalSizea,quotaMemory);
  }
  function bfloor(uint coalSize,  uint quotaMemory) constant internal returns (uint)
  {
    return calculate100Utility(coalSize,quotaMemory);
  }
  function abar(uint coalSize, uint agentWeight,  uint quotaMemory) constant internal returns (uint)
  {
    return calculate100Utility(coalSize + agentWeight,quotaMemory);
  }
  function bbar(uint[] budgetCoal, uint[] budgeta, uint coalSize, uint agentWeight,  uint quotaMemory) constant internal returns (uint)
  {
    return calculateUtility(budgetCoal,budgeta,coalSize + agentWeight,quotaMemory);
  }
  function winningCoalition(uint[] playerToCoalition, uint numberOfRepresentativesMemory,MyLib.Agent[] playerToAgent ) constant internal returns (uint)
  {
    uint[] memory weights = new uint[](numberOfRepresentativesMemory);
    //add all the weights
    for (uint i = 0; i < numberOfRepresentativesMemory ; i++)
    {
      weights[playerToCoalition[i]] += playerToAgent[i].weight;
    }
    for (i = 0; i < numberOfRepresentativesMemory ; i++)
    {
      if(weights[i] >= quota)
      {
        return i;
      }
    }
    return numberOfRepresentativesMemory;
  }

  function calculate100Utility(uint coalitionSize,  uint quotaMemory) constant internal returns (uint)
  {
    return (uint) ((coalitionSizeFactor * 100) / (quotaMemory + 1 - coalitionSize) + ((100-coalitionSizeFactor) * 100));
  }

  function calculateUtility(uint[] budget1,uint[] budget2, uint coalitionSize,  uint quotaMemory) constant internal returns (uint)
  {
    uint shared = sharedBudget(budget1,budget2);
    return (uint) ((coalitionSizeFactor * shared) / (quotaMemory + 1 - coalitionSize) + ((100-coalitionSizeFactor) * shared));
  }

  function sharedBudget(uint[] budget1,uint[] budget2) constant internal returns (uint)
  {
    uint shared = 0;
    for(uint i = 0; i < budget1.length; i ++)
    {
      if(budget1[i] > budget2[i])
      {
        shared += budget2[i];
      }
      else{
        shared += budget1[i];
      }
    }
    return shared;
  }
  function negotiate(uint a_bar,uint b_bar,uint a_floor,uint b_floor)constant  public returns (uint[])
  {
    uint gasCostMemory = gasCost;
    uint usefulTurn = ((a_bar + b_bar - a_floor - b_floor - 2) / gasCostMemory) + 1;
    uint[] memory proposal = new uint[](2);

    uint numberOfTurnsMemory = numberOfTurns;
    if(usefulTurn > numberOfTurnsMemory)
    {
      usefulTurn = numberOfTurnsMemory;

    }
    uint freeUtility = a_bar + b_bar - ((usefulTurn - 1) * gasCostMemory) - a_floor - b_floor - 2;
    if(usefulTurn % 2 == 0)
    {
      proposal[1] = b_floor + 1 + freeUtility + (((usefulTurn/ 2)-1) * gasCostMemory) + 1;
      proposal[0] = a_bar + b_bar -  proposal[1];
    }
    else
    {
      proposal[0] = a_floor + 1 + freeUtility +  ((((usefulTurn + 1)/ 2)-1) * gasCostMemory);
      proposal[1] = a_bar + b_bar -  proposal[0];
    }
    //cant go over the best amount
    if(proposal[0] > a_bar)
    {
      proposal[1] +=  proposal[0] - a_bar;
      proposal[0] = a_bar;
    }
    else if(proposal[1] > a_bar)
    {
      proposal[0] +=  proposal[1] - a_bar;
      proposal[1] = a_bar;
    }


    return proposal;



  }

  function negoToBudget(uint[] budget1, uint [] budget2, uint[] nego, uint coalitionSize) constant public returns (uint[])
  {
    uint[] memory newBudget = new uint[](budget1.length);

    uint sharedab = sharedBudget(budget1,budget2);

    uint quotaMemory = quota;
    uint individuala = (uint) (nego[0] / ((coalitionSizeFactor / (quotaMemory + 1 - coalitionSize)) + (100 - coalitionSizeFactor)) - sharedab);
    uint individualb = (uint) (nego[1] / ((coalitionSizeFactor / (quotaMemory + 1 - coalitionSize)) + (100 - coalitionSizeFactor))- sharedab);


    uint suma = 0;
    uint sumb = 0;

    for(uint i = 0; i < budget1.length; i ++)
    {
      if(budget1[i] > budget2[i])
      {
        suma += budget1[i];
      }
      else{
        sumb += budget2[i];
      }
    }

    uint total = 0;
    for(i = 0; i < budget1.length; i ++)
    {
      if(budget1[i] > budget2[i])
      {
        total +=  budget2[i] + individuala * budget1[i] / suma;
        newBudget[i] = budget2[i] + individuala * budget1[i] / suma;
      }
      else{
        total +=  budget1[i] + individualb * budget2[i] / sumb;
        newBudget[i] = budget1[i] + individualb * budget2[i] / sumb;
      }
    }
    uint z = 0;
    while(total < 100)
    {
      newBudget[z] += 1;
      total +=1;
      if(z == budget1.length - 1)
      {
        z = 0;
      }
      else
      {
        z ++;
      }
    }


    return newBudget;
  }
\end{lstlisting}
Again I tried to put as many variables I was using from storage multiple times on the stack and memory variables to save gas cost. \\
One problem I faced was that there is no built in decimal types in solidity. This is why my calculate utility has been scaled up by 100 times, it is now between 0 and 10,000. The larger the scale the more accurately I will be able to calculate utility. It also allows more granularity in coalition size factor and coalition size factor increase. Another problem caused by this is that when negotiating a budget between representative and coalition, the total budget would not sum up to 100. To  solve this at the end of negotiating it would give each sink one more unit in the budget until it summed up to 100. This causes the problem that earlier sinks will benefit from this much more than later. However smart contracts are deterministic and there is no way to randomise the orders. \\
Another implantation decision was to decide the order in which representatives take turns. I decided to leave the order of highest weight to lowest as it was. This was for two reason. First it would cost to reorder it, and because letting the biggest representative form coalitions first should end the negotiation earlier and save more gas.
I also created another function calculate100utility. This returns the utility if the preferred budget and budget are the same. This saved gas as I need this often, and finding out how much the preferred budget overlaps with the budget is expensive. \\
The negotiation function returned the utility for each agent. After finding the negotiation which returned the best utility for the representative, I then had to create a function negoToBudget which took the utility and the representative and coalition budgets and returned the new coalition budget. To do this first, I took each utility and increased it to what it would be if the coalition size was the quota. I then took each of them away from how much the budgets overlap. This gave me three uints,  shardedab which is how much of the budgets overlap, individuala which is how much of the negotiated budget is only in the representative preferred budget, and individualb which is how much of the negotiated budget is only the coalitions current budget. \\
After working out these 3 variables, the function then starting the creating the new budget. First, all the overlapping budget is wanted by both agents so the new budget has them as well. Then I had to decide how the individual a and b where spread. Due to the way I created my utility function, if two sinks are 20 units below the budget, it generated the same utility as one sink 40 units below the budget. I decided to spread the individual utility proportionally by how far away the other agent’s budget was from the agents. 
\section{Club Contract Website}