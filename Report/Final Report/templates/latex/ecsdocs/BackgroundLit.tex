%% ----------------------------------------------------------------
%% Background.tex
%% ---------------------------------------------------------------- 
\chapter{Background Literature} \label{Chapter: Background  Literature}
My background reading could be broadly separated into three fields; multi agent systems, Ethereum and smart contract design.
\section{Multi Agent Systems}
There are a number of voting systems each with different desirable properties \citep{Wooldridge:2009:pdflatex}. First off, there was a distinction between social welfare and social choice functions. They both took in a list of preferences from agents, however in social welfare it outputs a list of preferences, whereas social choice outputted a single option. In my system, I will require a social welfare function, as I need to select a number of representatives. For my program, voting preferences are important so that the representatives are representative of all the voters wants. Second order Copeland rating satisfies this. This is where each of the options has a pairwise election with all other options. It then adds the sum of all defeated opponents  to see what option is the best. This algorithm satisfies the Condorcet winner condition where w should be ranked first if it would defeat each other option in a pairwise election. This algorithm is Pareto optimal which means that if every one votes $w1>w2$ then the output should be $w1>w2$. Lastly, it also mentions the Gibbard-Satterwaite theorem which states that all voting systems are vulnerable to strategic manipulation. For my system, this is made worse by that fact that all transactions are transparent on a blockchain, making the manipulation even easier. However, second order Copeland rating is NP-complete to manipulate which makes it difficult to manipulate.  \\
Also from the book, there was a description on how to run a negotiation algorithm. The negotiation set, will be an array of sinks to values, where the values add up to the collected money. The negotiation algorithm is where Agent 1 makes a proposal. If it is rejected, then Agent 2 makes a proposal, then 1 etc. However, if no deal is reached after a certain number of rounds, then the players receive a conflict deal. In the book, two assumptions are made; agents seek to maximise utility and disagreement is the worst outcome. However, in my system, disagreement is not always the worst outcome. Another important point is that time is valuable and that agents are impatient. This means a deal w at round t1 is better than deal w at round t2 if $w1<w2$. The algorithm should create a Nash equilibrium, this means that no agent can increase his utility by changing actions. \\
Lastly, reading continued with the coalition section of the book. My system would be a weighted voting game. This is where each agent has a weight, we have a quota and a coalition C is winning if the sum of the weights exceeds the quota. A coalition is said to be stable if every agent cannot get a higher utility by defecting. \\
Coalitions can be formed by self interested rational agents who are trying to maximize their own utility \citep{Chalkiadakis:2012:pdflatex}. In particular, dynamic coalition form where coalitions can form and fall apart. One approach is a Markov process, where agents explore sub optimal coalition formation actions and at each stage there is a small probability that they try to move to a new coalition. A player switches coalitions if their expected utility, in the best available coalition, exceeds their current utility. The player also demands as much as they can from the coalition.
\section{Ethereum}
The first modern cryptocurrency was Bitcoin. At its core, Bitcoin is a state transition machine. It has a ledger of account values. It then receives a transaction e.g send 50 Bitcoin from Alice to Bob. If Alice has 50 Bitcoin, the next state is the same ledger but 50 Bitcoin subtracted from Alice and 50 more in Bob's account. Or else it transitions to a error. Also, Alice is able to verify she is sending it from her account by signing the transaction with her private key. \\
The next problem Bitcoin had to solve, was how to method to reach consensus, to make sure users agree with the set of transactions. To solve, this Bitcoin created a blockchain. This is a linked list of blocks. Each block contains a list of transactions sent in that block and the previous hash of last block. The previous hash is computationally intensive problem to solve, and so “miners” race to solve it and can put the next block on the blockchain. The system rewards the miners with Bitcoin to incentivise more computation to secure the network. \\
The hashing algorithm must be difficult to prevent a Sybil attack. This is where a peer to peer network is comprised, by creating a large number of pseudonymous identities. The reward is given to prevent a 50\% attack. This is where one person or group controls 50\% of the mining power. This would allow them double spend and send the same bitcoin multiple times.
Smart Contracts allow you to run scripts on the blockchain. Bitcoin can make basic smart contracts but has major limitations. First, it is not turning complete, for example loops cannot be implemented. Another problem is a lack of state, Bitcoin is either in or not in a users account. \\
To solve this problem Ethereum was created \citep{EthereumWhitePaper:2018:pdflatex}. This functions the same way as Bitcoin except the blockchain has a built in Turing complete programming language (solidity). Also, transactions can now be sent with more data, this allows you to send parameters to functions. Furthermore transactions have a STARTGAS field. This is how much gas the user is willing to spend on the transactions, and the transactions will fail if it goes over the limit. Lastly, transactions have a GASPRICE field, which is how much the Ethereum the user is willing to pay per transactions. Miners will prioritise transactions with higher gas prices, as they will receive more Ethereum for their work.  
\section{Smart Contract Design} 
Firstly, I found the benefits of using smart contracts. They are useful whenever you need “ applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third-party interference”  \citep{ethereum:2018:pdflatex}. \\
I also did research on writing smart contracts, and found the Truffle development environment. I then read through the Pet Shop tutorial \citep{Truffle:2017:pdflatex} . It showed how to set up the environment, create new contracts with functions and variables, and how to migrate and deploy the contracts. Once the contracts are deployed on Truffle's test network, it gives a number of addresses with Ethereum on them in order to test your contracts. These addresses can then interact with the functions on those contracts. Once you create the contract and deploy them, an interface can be made for the contract with web3. On my system, you will be able to register and vote on the interface, so that users do not have to use the command line. In order to use your Ethereum on a website, downloading the extension Metamask allows you to set your default account, and when you click register on the interface, it will send funds from that account. \\
Also, I researched how other applications on the Ethereum network had reduced their gas cost: one such app was a distributed social network. The majority of the gas consumption on smart contracts come from storing data. To reduce the amount of data stored, he used IPFS and Stateless Smart Contracts \citep{Childs-Maidment:2016:pdflatex}. IPFS take your key-value pair and store it as a hash, and then when access is needed to your key-value pair, you send the hash to IPFS, and it will return the key-value pair. IPFS is also decentralised so it does not compromise the trustless nature of smart contracts. Stateless Smart contracts have two parts; dumb functions and filters. A dumb function will take the parameters required but will do nothing. Then when you want to access the data on your interface, since all transactions are public, using InputDataDecoder, find what parameters were passed to the contracts functions.  \\
However, there are trade-offs with this approach. The first being tampering; the person who controls the interface could lie about what was sent,  although users could validate the transactions themselves which reduces the problem. It could also be a positive, as anyone can build a filter which could add extra data to improve user experience e.g media, metadata. Another problem is that smart contracts do not have access to all the transactions and will not be able to see your data. Lastly, if your contract has no events, it must process all transactions to find your data, but this can be mitigated by firing off random empty events. In my system, I will use a mix of standard and stateless functions. The voting and registering will be standard, but for functions such as messaging, gas can be saved by making it stateless. \\
This was a smart contract \cite{Merriam:2017:pdflatex} had put on the blockchain that allowed you to pay someone to run functions after a certain number of blocks. This would be useful, as I need time limits on voting, submitting a budget, term limits and registration and I need to run a function periodically to check that the time limits had not been reached yet. \\
I also needed to research common vulnerabilities in Smart Contracts. One common attack is Reentrancy \citep{Grincalaitis:2017:pdflatex}. This is where users can interrupt the normal running of the function.  Therefore, in my system before any actions occur, I will set the conditions to false. Another attack is under and overflows, for uint256 any number above 2**256 will be set to 0 and 0 - 1 will be 2**256. Lastly, any function which is not changing the state of the application should be labelled as constant, to save gas.
In order to work out how much each transaction will cost, I will use \citet{ethgas:2018:pdflatex} to find out median gas price and \citet{coinmarket:2018:pdflatex} to work out the cost of Ethereum in USD. I will use coinmarketcap over trading sites like Coinbase as coinmarketcap uses a weighted average and is therefore more reliable.