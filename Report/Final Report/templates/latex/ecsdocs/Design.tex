%% ----------------------------------------------------------------
%% FinalDesign.tex
%% ---------------------------------------------------------------- 
\chapter{Final Design} \label{Chapter: Final Design}
\section{How Registration Fee Collected}
One of my goals was that the owner of the system does not have any extra control over the money and the data. I will compare the use of a Clubs and Charites Account (Santander) with using a Smart Contract on the Ethereum Blockchain. 
\\
Fee collection table here
\\
The benefits of the Clubs and Charites Account is that it costs 0 to run and set up, whereas it can be expensive to store data on the Blockchain. The problem is that only 3 members are required to access the account. This is made worse as the signatories would have to change annually which would require a lot of time and effort. Also if one of the signatories is busy, then the club would be unable to access the funds. Compared to the smart contract, which would do this automatically.  Another problem is that although the registration is legally non repudiable, a member would have to take the club to small claims to enforce it. Lastly the account is viewable by the signatories, therefore a regular member can not confirm how much money has been gathered and where it has spent. However a smart contract all members can see how much money has been gathered and where it has been spent.
From this I decided that the best design was a smart contract, however care must be taken to keep the Gas (how many instruction used) used down. Also to monitor the Gas Price (cost miners are changing to run a instruction) which this year to date has fallen by 70\%, and the price of Ethereum in GBP. Also Another problem to consider is that if a user loses his private key to his Ethereum account it is unrecoverable and you will lose the ability to prove you registered.
\section{How Registered Users Are Stored}
A feature of blockchain is all data stored on it is publicly visible. Therefore, thought must be put into how much data is stored about each user. At minimum we must store the registered users public address. However storing only the users address will make it so communication and accountability is hindered, as a public address is long and non memorable, and will make it hard to see who said and did what. I decided that storing the address and name was the best compromise. In the rare situation two users had the same name and there was argument on who did what, it would not be too much effort for one of them to digitally sign using their private address.
\section{Voting Algorithm}
The voting algorithm to choose representatives is a social welfare function which takes a list of ordered preferences and outputs a ordered preference. I compared a few algorithms to see which best bit my problem.
\\
Voting algo table
\section{How to start and end Voting}
Voting should start a “term length” after the last voting had ended and the voting should end after “voting length” after the voting had started. Both term length and voting length are set when the club contract is made. However the smart contract is not constantly running, and therefore needs to have a function called. I have two options for calling the functions. First I could use “Ethereum Alarm Clock”. This allows my smart contract to pay someone to run the function at a certain block time. The other option is waiting for one of the users to run the start and end vote functions. The first option has the benefit that we can assume that the voting period will end at a more precise time. The latter has the benefit that it is cheaper.
\\
I decided to go for the latter, as in my case a few extra minutes or hours of voting, should not be a significant problem. And if it is, then users could send the function as quickly as possible. If the club has a small number of users the first option might be better as there is a greater chance all the users forget to end the voting period.
\section{How many Representatives}
An important design decision, is how many representatives should be elected. The trade off is between the system being more representative and the system being cheaper to run. Because the voting algorithm compares each candidate in a pair wise election, the gas cost is exponential to the number of representatives. In my system the number of representatives will be set when the contract is created. Also due to the fact in can have a large impact on the cost of the contract, if users wish to change it, a super majority should be acquired.
\section{How to choose their Weight}
After the voting algorithm is complete it will output a list of ranked representatives. From this point the system will need to determine how much weight they have in the budget negotiations. One example system  could be weighting the 1st ranked representative, number of representatives, the 2nd, number of representatives – 1 and so on. Another system could be weighting them all one. These are common methods and found in numerous other systems and therefore my system should make it easy to choose these two methods. However in order to make the system more flexible, my system should allow the creator to also create their own function.
\section{How many Sinks and who can create them}
Another decision is how many sinks (budget expenditures), should be allowed to be created. Again the system will allow you to choose the number at contract creation. The benefit of more sinks is that the money will more distributed more and each manager will have more time to focus on a sink with less responsibilities. The disadvantage is that communicated between the managers may be poor, and double spending could occur. Another problem is that due to economies of scale, money concentrated in fewer hands may be able to afford more items . lastly it will raise the gas price of the budget negotiation. However since it only affects the cost linearly, the system should only require a plurality to change the number of sinks.
\\
Also the system must have a system for submitting sinks. I have identified 3 ways to do this. First, all users have the ability, second all representatives have the ability and last, each sink is proposed and then voted on. The first option has the benefit that the system is more interactive for more users. However it is prone to abuse, as being a user only requires paying the fee, and a malicious person could fill up the sinks with bogus sinks.  The second option is less like to be abused, as representatives are likely to have a greater attachment to the club. The last option should prevent all abuse, however it is time consuming to have to vote on each sink, and could end up costing a lot of money to run each vote. Therefore I have decided on my second option.
\section{When can Budget submit end}
\section{Budget Negotiation Algorithm }
The first and easiest idea for deciding the budget was to take each representatives budget, sum each one and divide by number of representatives. This would be cheap to run and sounds fair. The problem occurs with that all budgets submitted are publicly viewable, and with this algorithm a representative could easily manipulate his budget to achieve the final budget he wanted. 
A better algorithm would be for each representative to try and form coalitions with his peers, until the coalition reached a certain quota. This solves the problem of a representative submitting a extreme budget to manipulate the final budget, as the other representatives would just form a coalition without him.  
The next step was to create a function which took a representative’s budget, their current coalition’s budget, and the current size of the coalition and returned the representative’s current utility. To make the utility easy to understand, the range of the function will be from 0 to 100. 100 utility would be when the coalition size is the quota and the coalition budget is the representatives preferred budget. The function I decided on was as followed.
Next I had to decide how coalitions would be formed. The first step would be to initialise each representative with his own coalition with his preferred budget. From this point I had to decide whether representatives would take turns joining coalitions or coalitions would take turns inviting representatives. The negatives of coalitions inviting representatives is that larger coalitions would have more chance to have a representative stolen by another coalition and therefore take longer and cost more to calculate. The advantage is that there would be more negotiations and that should result in a more balanced budget. One problem with both of these solutions is that it could lead to a infinite loop and never end, however the joining coalitions method resulted in a lot less of them. Therefore I will use that method. Representatives will take turns, negotiating with each coalition, they will then compare their utility by joining their coalition and choose the coalition which offers the best utility, or stay in the current coalition if its better utility then all offers. 
However any infinite loops are unacceptable in the algorithm. To solve this I came up with two solutions. First, representatives could be impatient, this means that a budget in round n is better than a budget in round m if n < m. Another method is to make the coalition size less relevant is earlier turns and make it more important in later turns. The first method allows representatives to look forward to later rounds in order to make an more informed decision. However to work out the single negotiation would be factorial, and therefore unusable with a medium number of representatives. For this reason I will use the second method. With the new utility function as follows.  
The next decision was how representatives would negotiate with coalitions. I used the model of the alternating offers game with impatient agents. I will therefore use back propagation to work out what the optimal starting offer is for both agents.






